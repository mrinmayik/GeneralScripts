#!/bin/tcsh

#This script is got from the afni demos distributed at the Milwaukee AFNI Bootcamp.
#It has been modified by Mrinmayi Kulkarni (mrinmayi@uwm.edu) to make it usable across projects
#Any lines that have been modified have a #modified comment so that my stupidity is not mistaken for
#the original script

#The following modifications have been made in this script:
#	1. This afni_proc command only does preprocessing, and NOT regression. This is just to make sure that 
#		standard preprocessing can be applied uniformly to all projects across projects
#	2. An additional argument that takes in the name of the project is added here. This argument is now
#       required. This is to ensure that c.0.initvars does not need to be editted for each project separately
#	3. An additional argument that takes in the name of the task is added here. This argument is now
#       required.
#	3. Additional arguments that take in the number of dummy scans at the start of the epi, tlrc, slice-time
#       correction, blurring is added here and passed to c.ss.3.AP*.
#	4. Existence of this file, argument and project folder is verified before running c.ss.3.AP*
#	5. The name is passed to c.ss.3.AP*. c.ss.3.AP* has been accordingly modified to expect this
#		as an argument


# ===================== based on S.0.template.txt ======================

# Run afni_proc.py for a subject list passed on the command line.

# Now, build a script of commands to run.

# ======================================================================
# init variables and allow command line options:
#    script_dir, study_root_in, study_root_out, deriv_dir,
#    all_subjects, nsubj
# Note that script_dir will need to be set basically every
#      time, since calling 'init_vars' will be universal.

# --------------------------------------------------
# variables to propagate to other scripts (always pass)

# the location of processing scripts (use full path)
set script_dir = `pwd`

# verbosity level
set verb = 0

set redo = 0

set allow_missing = 0

# taskname to process
set taskname = 0 # modified
set tasknum = 0

# project we're working on 
set project = 0 # modified

# where are NIFTIs stored
set input_dir = rawdata

# default AP inputs
set dummy_scans = 5 # modified
set smooth = Y
set blur_size = 6
set stc = Y
set stc_pattern = alt+z2
set tlrc = Y

# set proc_dir
set proc_dir = 0 # modified

# are we swarming this?
set swarm = 0

# output directory where SSwarper results are stored
set SSW_dir = AFNI_01_SSwarper

# --------------------------------------------------
# variables specifiec to this script

# the name of this script
set prog = `basename $0`

# list of subjects to process
set subj_proc_list = ()

# ======================================================================
# process command-line arguments
set ac = 1
while ( $ac <= $#argv )
   if ( "$argv[$ac]" == "-help" ) then
      echo "$prog       - run preprocessing on specified task and subjects using afni_proc.py"
      echo ""
      echo "usage: $prog [options...] subj subj ..."
      echo ""
      echo "options specific to this script"
      echo ""
      echo "  -project PATH       : path to project folder that you're working on" # modified
      echo "  -taskname NAME  NUM : name of the task you want to process and number" # modified
      echo "                           of runs of this task" # modified
      echo "  -input_dir PATH     : folder in [project] where NIFTIs are stored" # modified
      echo "                           default: rawdata"
      echo "  -proc_dir DIR       : root directory under 'derivates' for results"
      echo "                           default: AFNI_02_[taskname]" # modified
      echo "  -SSW_dir DIR        : directory under 'derivates' where SSwarper results are stored"
      echo "                           default: $SSW_dir" # modified
      echo "                           Note: This scripts REQUIRES that SSwarper is run because it"
      echo "                              it will use transforms from this folder for alignment"
      echo "  -dummy_scans NUM    : number of dummy scans to be discarded" # modified
      echo "                           default: $dummy_scans"
      echo "  -stc Y/N PATTERN    : whether to turn on slice-time correction (default=$stc) and" # modified
      echo "                           direction of slice acquisition. See 3dTshift -help for info"
      echo "                           default: $stc_pattern"
      echo "  -tlrc Y/N           : whether to non-linearly warp EPIs to standard space "
      echo "                           default: $tlrc"
      echo "  -smoothing Y/N FWHM : whether to turn on smoothing (default=$smooth) and kernel " # modified
      echo "                           size to use for smoothing"
      echo "                           default: $blur_size"
      echo ""
      echo "general options"
      echo ""
      echo "  -help               : show help and exit"
      echo "  -verb LEVEL         : set verbosity level (2 means show commands)"
      echo "                           default: $verb"
      echo "  -allow_missing      : skip missing subjects, but proceed"
      echo "  -redo               : (delete previous and) re-create results"
      echo "  -script_dir DIR     : specify directory of processing scripts"
      echo "                           default: $script_dir"
      echo "  -swarm              : use HPC swarm for this process"
      echo ""
      exit 0
   # modified
   else if ( "$argv[$ac]" == "-project" ) then
     @ ac ++
     if ( $ac > $#argv ) then
        echo "** -project: missing argument"
        exit 1
     endif
     set project = $argv[$ac]
   else if ( "$argv[$ac]" == "-taskname" ) then
     @ ac ++
     if ( $ac > $#argv ) then
        echo "** -taskname: missing argument"
        exit 1
     endif
     set taskname = $argv[$ac]
     @ ac ++
     if ( $ac > $#argv ) then
        echo "** -taskname: missing argument"
        exit 1
     endif
     set tasknum = $argv[$ac]
   else if ( "$argv[$ac]" == "-input_dir" ) then
     @ ac ++
     if ( $ac > $#argv ) then
        echo "** -input_dir: missing argument"
        exit 1
     endif
     set input_dir = $argv[$ac]
   else if ( "$argv[$ac]" == "-proc_dir" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -proc_dir: missing argument"
         exit 1
      endif
      set proc_dir = $argv[$ac]

   else if ( "$argv[$ac]" == "-SSW_dir" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -SSW_dir: missing argument"
         exit 1
      endif
      set SSW_dir = $argv[$ac]
   else if ( "$argv[$ac]" == "-dummy_scans" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -dummy_scans: missing argument"
         exit 1
      endif
      set dummy_scans = $argv[$ac]
   else if ( "$argv[$ac]" == "-stc" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -smoothing: missing argument"
         exit 1
      endif
      set stc = $argv[$ac]
      #only get blur size if smoothing is set to on
      if ( $stc == Y ) then
          @ ac ++
          if ( $ac > $#argv ) then
             echo "** -smoothing: missing argument"
             exit 1
          endif
      set stc_pattern = $argv[$ac]
      endif
   else if ( "$argv[$ac]" == "-tlrc" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -tlrc: missing argument"
         exit 1
      endif
      set tlrc = $argv[$ac]	 
   else if ( "$argv[$ac]" == "-smoothing" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -smoothing: missing argument"
         exit 1
      endif
      set smooth = $argv[$ac]
	  #only get blur size if smoothing is set to on
	  if ( $smooth == Y ) then
	      @ ac ++
	      if ( $ac > $#argv ) then
	         echo "** -smoothing: missing argument"
	         exit 1
	      endif
	      set blur_size = $argv[$ac]
	  endif
   else if ( "$argv[$ac]" == "-allow_missing" ) then
      set allow_missing = 1
   else if ( "$argv[$ac]" == "-redo" ) then
      set redo = 1
   else if ( "$argv[$ac]" == "-script_dir" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -script_dir: missing argument"
         exit 1
      endif
      set script_dir = $argv[$ac]
   else if ( "$argv[$ac]" == "-swarm" ) then
      set swarm = 1
   else if ( "$argv[$ac]" == "-verb" ) then
      @ ac ++
      if ( $ac > $#argv ) then
         echo "** -verb: missing argument"
         exit 1
      endif

      # if 2 or more, set echo to see commands
      if ( $verb >= 2 ) set echo
   else
      # everything else should be a subject
      set subj_proc_list = ( $argv[$ac-] )
      break
   endif

   @ ac ++
end

# check that necessary arguments have been passed
# project path is needed because this path needs to be passed to c.0.int_vars
# taskname is required to set output directory name etc
set neededargs = ( $project $taskname $tasknum )
set neededvars = ( project taskname tasknum )
foreach ac ( `seq 1 $#neededargs` )
   if ( $neededargs[$ac] == 0 ) then
	   echo "-$neededvars[$ac] is missing"
	   exit 1
   endif
end


# this corresponds to the command script that is run, c.ss.$cmd_label
# e.g. c.ss.3.make_spec
# set cmd_label = 4.AP.$taskname.NL.blur
set cmd_label = 3.AP.$taskname

# processing directory that goes under derivatives
# ** for this script, dirs must correspond with those in c.ss.$cmd_label
# if proc_dir was not set from command line, set it based on taskname
if ( $proc_dir == 0 ) then
	set proc_dir = AFNI_02_${taskname}
	
	echo "** no -proc_dir was passed"
	echo "** setting proc_dir to $proc_dir"
endif



# source the variable init file (to keep them mostly in one place)
# sets: study_root_in, study_root_out, deriv_dir, all_subjects, nsubj
source $script_dir/c.0.init_vars -project $project -input_dir $input_dir

# modification ends

# ======================================================================
# do some work...

echo "== time == starting : `date`"

# if subj_proc_list was not initialized, process everyone
if ( $#subj_proc_list == 0 ) then
   set subj_proc_list = ( $all_subjects )
   echo "++ $prog : processing all subjects"
endif
echo "-- $prog : processing $#subj_proc_list subjects"

# input directory will be for the de-obliqued results under derivatives
#set in_dir = $study_root_in

# output directory will be for FreeSurfer
set res_dir = $deriv_dir/$proc_dir
echo "-- $prog : results will go under $res_dir"
echo "-- $prog : processing the following subjects $subj_proc_list" # modified
echo "" # modified

# for each subject, mask sure they exist
set missing = 0
set done    = 0
set todo    = 0
set nredo   = 0
set missing_run = 0 # modified
set subjs_todo = ()
foreach sid ( $subj_proc_list )
   # check if subject exists
   if ( ! -d $in_dir/$sid ) then
	   echo "** subject $sid  not present in $in_dir"
	   exit 1
   endif
   set func_dir = $in_dir/$sid/func
   
   # if redo, delete old
   set final_dir = $res_dir/$sid/$sid.results
   if ( $redo &&  -d $final_dir ) then
      echo "-- deleting AP result for subject $sid for re-run"
      @ nredo += 1
      \rm -fr $final_dir $res_dir/$sid/proc.$sid
   endif
   # check a couple of inputs
   # modified
   # loop through however many runs of this task the user has entered
   foreach run ( `seq 1 $tasknum `)
      if ( ! -f $func_dir/${sid}_task-${taskname}_run-${run}_bold.nii ) then
		 echo "** subject $sid missing run $run"
         @ missing_run += 1
      endif
   end
   # check for anats
   if ( ! -f $deriv_dir/$SSW_dir/$sid/anatQQ.${sid}_WARP.nii ) then
      echo "** subject $sid missing SSwarper results"
      @ missing_run += 1
   endif
   
   if ( $missing_run > 0 ) then
      echo "** subject $sid missing data"
      @ missing += 1 # modification ends
   else if ( -d $final_dir ) then
      echo "-- yay, already done with subject $sid"
      @ done += 1
   else
      set subjs_todo = ( $subjs_todo $sid )
	  mkdir -p $res_dir/$sid
      @ todo += 1
   endif
end

echo ""
echo "-- $prog subjects: $missing missing, $done already done, $todo todo"
echo "                   $nredo redo"
echo ""

# allow missing subjects?  seems like an error, but there could be reasons
if ( $missing > 0 ) then
   if ( $allow_missing ) then
      echo "** $prog : proceeding even with $missing missing subjects ..."
      sleep 3
   else
      echo "** $prog : will not proceed if any subjects are missing"
      exit 1
   endif
endif

# now either write a swarm script or directly fire off the process

# prep for swarm
if ( $swarm ) then
   mkdir -p $script_dir/out/run.$cmd_label
   cd $script_dir/out/run.$cmd_label
   set swarmfile = swarm.$cmd_label
   echo -n "" >! $swarmfile
endif

# setenv SUBJECTS_DIR $res_dir

# big finish, actually process some data
foreach sid ( $subjs_todo )
   # input data comes from the deoblique tree under derivatives
   # slurm takes: SID INDATA_ROOT RUN_SCRIPT OUTDATA_ROOT ...
   # $in_dir and $res_dir were set in checking for inputs and results

   # this is special: in_dir is orig data root, and also pass
   # the derivative root (for other inputs)
   set cmd = ( tcsh $script_dir/b.slurm $sid $in_dir \
                    $script_dir/c.ss.3.AP $in_dir $deriv_dir $taskname $tasknum $SSW_dir $res_dir $dummy_scans $stc $stc_pattern $tlrc $smooth $blur_size ) # modified

   # either write to swarm file or just run
   if ( $swarm ) then
      echo $cmd >> $swarmfile
   else
      echo "++ running: $cmd"
      $cmd
   endif
end

# possibly run swarm command
if ( $swarm ) then
   echo ""
   echo "++ swarming $#subjs_todo subjects via file $swarmfile"
   echo ""

   swarm -f $swarmfile                          \
        -g 8 -t 4                               \
        --time 20:00:00 --gres=lscratch:50      \
        --verbose 2                             \
        --module afni                           \
        --module python/2.7                     \
        --merge-output

   # tcsh p.3.make_spec -redo -swarm
   #
   # jobload
   # squeue -u $USER
   # scancel --user=$USER
endif

echo "== time == finished: `date`"
